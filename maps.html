<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="jquery-ui.css" />
    <script src="d3.v2.js"></script>
    <script src="jquery-1.8.2.js"></script>
    <script src="jquery-ui.js"></script>
    <script src="ultbuttons.js"></script> <!-- fix jQuery UI bug with checkbox buttons -->
    <style>
      td {padding: 0 1em;}
    </style>
  </head>
  <body>
    <script>
//d3.nodes.prefix.gml = "http://graphml.graphdrawing.org/xmlnodes";

String.prototype.trim=function(){return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');};

// --- mini vector library --------------------------------------------
// vectors are arrays [x,y] (2-dimensional)
// I cannae believe D3.js has no vector operations

var octilinear = function() {
  var x = 1/Math.sqrt(2);
  return [[1,0],[x,x],[0,1],[-x,x],[-1,0],[-x,-x],[0,-1],[x,-x]]
}();

function dot(v1, v2) { // V -> V -> R
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function centroid(vs) { // [V] -> V
  function c(i) { return d3.sum(vs, function(v) {return v[i]})/vs.length; }
  return [c(0), c(1)];
}
function scale(k, v) { // R -> V -> V
  return [k*v[0], k*v[1]];
}
function norm(v) { // V -> R (Euclidean)
  return Math.sqrt(v[0]*v[0]+v[1]*v[1]);
}
function vec(p) { // {x:R, y:R} -> V
  return [p.x,p.y];
}
function vec2(p1,p2) { // {x:R, y:R} -> {x:R, y:R} -> V (from p1 to p2)
  return [p2.x-p1.x, p2.y-p1.y];
}
function maxr(as, f) { // returns the value that is max by f (not f(v))
  var m = as[0], fm = f(as[0]);
  as.forEach(function(a) {var fa = f(a); if (fa > fm) {m = a; fm = fa}});
  return m;
}

// --------------------------------------------------------------------

var nodetable = {}
var nodes = [];
var links = [];
d3.xml("greek2.graphml", function(doc) {
  var format = d3.time.format("%d/%m/%Y");
  // TODO: The first step is to simplify our graph by removing all
  // straight line segments of the graph.  The end result
  // should be a new list of key nodes (nodes with adjacent edge
  // count not equal to two) and edges for all of those nodes, with
  // weight equal to the number of edges that they are representing.
  // For example:
  //   A -- B -- C -- D
  // reduces to:
  //   A -- D  (with edge weight = 3)
  d3.select(doc).selectAll("node").each(function () {
    var e = d3.select(this);
    var id = e.attr("id");
    var sx = parseInt(e.select("data[key='x']").text()),
        sy = parseInt(e.select("data[key='y']").text());
    var node = {
      label: e.select("data[key='label']").text().trim(),
      date: format.parse(e.select("data[key='date']").text().trim()),
      sx: sx,
      sy: sy,
      //x: sx/100,
      //y: sy+200,
      fixed: 0,
    };
    nodetable[id] = node;
    nodes.push(node);
  });
  d3.select(doc).selectAll("edge").each(function () {
    var e = d3.select(this);
    var n1 = e.attr("source");
    var n2 = e.attr("target");
    links.push({
      source: nodetable[n1],
      target: nodetable[n2]
    })
  });
  run();
});

var margin = {top: 30, right: 200, bottom: 40, left: 50},
    width = 800 - margin.right - margin.left,
    height = 500 - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("tranodesform", "tranodeslate(" + margin.left + "," + margin.top + ")");

var force;
function run() {

  var first = true; // don't enforce octilinearity to get good layout

  force = d3.layout.force()
      .nodes(nodes)
      .links(links)
      .charge(-100)
      .gravity(0.1)
      .linkStrength(1) // still not sure what the right parameter for this is
      .linkDistance(40)
      .size([width, height]);

  function dragmove(d) {
    var dx = d3.event.x - d.px;
    var dy = d3.event.y - d.py;
    if (d.fixed & 1) {
      nodes.forEach(function(node) {
        if (node.fixed & 1) {
          node.px += dx;
          node.py += dy;
          // Also set x,y for when force updating is turned off
          node.x = node.px;
          node.y = node.py;
        }
      });
    } else {
      d.px += dx;
      d.py += dy;
      // ditto
      d.x = d.px;
      d.y = d.py;
    }
    maybeResume();
  }
  // Cribbed from the original drag source.
  var drag = d3.behavior.drag()
        .origin(function(d) {return d})
        .on("dragstart", function(d) {d.fixed |= 2})
        .on("drag", dragmove)
        .on("dragend", function(d) {d.fixed &= 1});

  mydrag = function() {
    this.on("mouseover.force", function(d) {d.fixed |= 4})
        .on("mouseout.force", function(d) {d.fixed &= 3})
        .call(drag);
  };

  svg.selectAll("circle")
    .data(nodes)
    .enter()
    .append("circle")
    .attr("r", 8)
    .attr("stroke", function (d) { return d.fixed & 1 ? "#EEE" : "#000" })
    .attr("stroke-width", 3)
    .attr("fill", "#FFF")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .call(mydrag)
    .on("dblclick", function(d) { d.fixed = !d.fixed; });

  svg.selectAll("line")
    .data(links)
    .enter()
    .insert("line", "circle")
    .style("stroke", "#000")
    .style("stroke-width", 7);

  // XXX if the range here starts at 0.2, we get "snap" motion of
  // the metro map, but the force layout doesn't do as well.
  var octoscale = d3.scale.linear().domain([0.1,0]).range([0,1]);

  force.on("tick", function(e) {
    $("#alpha-slider").slider("value", e.alpha);
    $("#alpha-readout").text(e.alpha);
    // enforce octilinearity (hard constraint)
    // XXX but don't enforce it at the very beginning (first)
    // this is kind of complicated
    var k = first ? 0 : octoscale(e.alpha);
    if (e.alpha < 0.015 && first) {
        //force.gravity(0.001); // turn it off? has funny effects
        force.resume();
        first = false;
        return;
    }
    links.forEach(function(link) {
      // discover the closest octilinear direction (dir is
      // the orthonormal vector for that direction), and then
      // calculate the new link by rotating around the centroid
      // to align with that direction.)
      var v = vec2(link.source, link.target);
      // XXX how to stop overlapping?  nudging the edge too far is
      // not stable...
      // XXX this should respect friction
      var dir = maxr(octilinear, function(x) {return dot(x,v)});
      // XXX refactor me, extra lines for handling 'fixed' nodes
      if (link.source.fixed & 1) {
        var center = vec(link.source);
        var ray = scale(norm(v), dir);
        link.target.x += (center[0] + ray[0] - link.target.x) * k;
        link.target.y += (center[1] + ray[1] - link.target.y) * k;
      } else if (link.target.fixed & 1) {
        var center = vec(link.target);
        var ray = scale(norm(v), dir);
        link.source.x += (center[0] - ray[0] - link.source.x) * k;
        link.source.y += (center[1] - ray[1] - link.source.y) * k;
      } else {
        var center = centroid([vec(link.source), vec(link.target)]);
        var ray = scale(norm(v)/2, dir);
        link.source.x += (center[0] - ray[0] - link.source.x) * k;
        link.source.y += (center[1] - ray[1] - link.source.y) * k;
        link.target.x += (center[0] + ray[0] - link.target.x) * k;
        link.target.y += (center[1] + ray[1] - link.target.y) * k;
      }
    });
    redraw();
  });

  function redraw() {
    // redraw
    svg.selectAll("circle")
      .attr("stroke", function (d) { return d.fixed & 1 ? "#EEE" : "#000" })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
    svg.selectAll("line")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
  }

  force.start();

  function maybeResume() {
    // don't resume if paused
    if (!$("#pause-toggle").is(':checked')) {
      force.resume();
    } else {
      redraw();
    }
  }
  $("#charge-slider").slider({
    min: 0,
    max: 600,
    value: -force.charge(),
    slide: function(e, ui) {
      force.charge(-ui.value);
      $("#charge-readout").text(-ui.value);
      maybeResume();
    },
  });
  $("#gravity-slider").slider({
    min: 0,
    max: 0.3,
    step: 0.01,
    value: force.gravity(),
    slide: function(e, ui) {
      force.gravity(ui.value);
      $("#gravity-readout").text(ui.value);
      maybeResume();
    },
  });
  $("#friction-slider").slider({
    min: 0,
    max: 1,
    step: 0.01,
    value: force.friction(),
    slide: function(e, ui) {
      force.friction(ui.value);
      $("#friction-readout").text(ui.value);
      maybeResume();
    },
  });
  $("#link-strength-slider").slider({
    min: 0,
    max: 1,
    step: 0.01,
    value: force.linkStrength()(), // XXX weird bug https://github.com/mbostock/d3/issues/895
    slide: function(e, ui) {
      force.linkStrength(ui.value);
      $("#link-strength-readout").text(ui.value);
      force.start(); // special treatment
    },
  });
  $("#link-distance-slider").slider({
    min: 0,
    max: 80,
    value: force.linkDistance()(), // XXX weird bug (see above)
    slide: function(e, ui) {
      force.linkDistance(ui.value);
      $("#link-distance-readout").text(ui.value);
      force.start(); // special treatment (ditto)
    },
  });
  $("#alpha-slider").slider({
    min: 0,
    max: 0.1,
    step: 0.00001,
    value: 0.1,
    slide: function(e, ui) {
      force.alpha(ui.value);
      $("#alpha-readout").text(ui.value);
    },
  });
  // XXX bleh
  $("#charge-readout").text(force.charge());
  $("#gravity-readout").text(force.gravity());
  $("#friction-readout").text(force.friction());
  $("#link-strength-readout").text(force.linkStrength()());
  $("#link-distance-readout").text(force.linkDistance()());
  $("#clear-fixed-button").click(function() {nodes.forEach(function(n) {n.fixed = 0;})});
  $("#resume-button").click(function() {force.resume(); $("#pause-toggle").prop('checked', false).button("refresh");});
  var oldalpha = 0.1;
  $("#pause-toggle").button();
  $("#pause-toggle").change(function() {
    if (this.checked) {
      oldalpha = force.alpha();
      force.stop();
    } else {
      force.alpha(oldalpha);
    }
  });
  $("#stop-button").click(function() {force.stop()});
  $("#tick-button").click(function() {force.tick()});
}
    </script>
    <div id="controls">
      <table id="sliders">
        <tr><td>Charge</td><td width="400px"><div id="charge-slider"/></td><td id="charge-readout"></td></tr>
        <tr><td>Gravity</td><td><div id="gravity-slider"/></td><td id="gravity-readout"></td></tr>
        <tr><td>Friction</td><td><div id="friction-slider"/></td><td id="friction-readout"></td></tr>
        <tr><td>Link strength</td><td><div id="link-strength-slider"/></td><td id="link-strength-readout"></td></tr>
        <tr><td>Link distance</td><td><div id="link-distance-slider"/></td><td id="link-distance-readout"></td></tr>
            <tr><td>Alpha</td><td><div id="alpha-slider"/></td><td id="alpha-readout"></td></tr>
      </table>
      <label for="pause-toggle">Pause</label><input type="checkbox" id="pause-toggle" />
      <button id="clear-fixed-button">Clear fixed</button>
      <button id="resume-button">Restart</button>
      <button id="stop-button">Stop</button>
      <button id="tick-button">Tick</button>
    </div>
  </body>
</html>
